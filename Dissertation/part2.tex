\chapter{ОПИСАНИЕ АЛГОРИТМОВ}\label{ch:ch2}

\section{Формализация задачи распределения ресурсов}\label{sec:ch2/sec1}

\subsection{Система как граф}\label{sec:ch2/sec1/subsec1}

Систему управления ресурсами можно представить как граф:

\begin{equation}
	G = (V, E), \quad V = N \cup D, \quad N = \{n_1, n_2, \ldots, n_k\}, \quad D = \{d_1, d_2, \ldots, d_m\}
\end{equation}

где:
\begin{itemize}
	\item $N$ -- множество edge-узлов (поставщиков вычислительных ресурсов);
	\item $D$ -- множество IoT-устройств (потребителей ресурсов);
	\item $E$ -- множество рёбер сетевой топологии;
	\item вес каждого ребра $w(d_i, n_j)$ отражает сетевую задержку между устройством и узлом.
\end{itemize}

Такая графовая модель позволяет естественным образом представить иерархическую структуру облачно-периферийной системы, где различные edge-узлы могут быть на разных уровнях иерархии.

\subsection{Характеристики ресурсов и требования задач}\label{sec:ch2/sec1/subsec2}

Каждый edge-узел $n_j \in N$ характеризуется вектором доступных ресурсов:

\begin{equation}
	\text{Cap}_j = (\text{CPU}_j, \text{MEM}_j, \text{Bandwidth}_j, \text{Storage}_j)
\end{equation}

и текущей загрузкой:

\begin{equation}
	\text{Load}_j(t) = (\text{CPU}_{\text{avail}}(t), \text{MEM}_{\text{avail}}(t), \ldots)
\end{equation}

которая меняется со временем в зависимости от уже выполняемых задач.

Каждое устройство $d_i \in D$ генерирует вычислительные задачи из множества $T_i(t)$ в момент времени $t$, где каждая задача $\tau$ характеризуется:
\begin{itemize}
	\item \textbf{Требования к ресурсам:} $(\text{CPU}(\tau), \text{MEM}(\tau), \text{Bandwidth}(\tau))$;
	\item \textbf{Объём данных:} $\text{DataSize}(\tau)$;
	\item \textbf{Временной дедлайн:} $\text{Deadline}(\tau)$;
	\item \textbf{Приоритет:} $\text{Priority}(\tau) \in [0, 1]$;
	\item \textbf{Тип задачи:} $\text{Type}(\tau)$ (интерактивная, batch, критическая и т.д.).
\end{itemize}

\section{Алгоритм MA-VCG (Multi-Agent Vickrey-Clarke-Groves)}\label{sec:ch2/sec2}

Моделирование распределения ресурсов можно представить как виртуальный рынок~\cite{gorodetskii}, на котором агенты участвуют в аукционе (см. рис. \ref{img:arch-ma-vcg}). Агенты IoT-устройств выступают как покупатели вычислительных ресурсов, агенты Edge-узлов -- как продавцы, а специальный агент-аукционер координирует весь процесс. 

\begin{figure}[h]
	\centering
	\includegraphics[width=10cm, height=8cm]{arch-ma-vcg}
	\caption{Концептуальная архитектура виртуального рынка}
	\label{img:arch-ma-vcg}
\end{figure}

Алгоритм MA-VCG представляет собой адаптацию классического аукционного механизма Викри-Кларка-Гровса (VCG) для многоагентной среды распределения ресурсов в IoT-системах. В отличие от традиционного VCG, работающего в один момент времени, MA-VCG предназначен для повторяющихся аукционов, где параметры функций полезности и стоимости обновляются на основе накопленного опыта.

\textbf{Основная идея:} В каждый временной интервал система выполняет раунд аукциона, в котором реализуется трехфазный протокол:
\begin{enumerate}
	\item Фаза сбора инфорации (Submission Phase): устройства IoT подают заявки с информацией о своих задачах и требуемых ресурсах, а edge-узлы объявляют информацию о своей доступной ёмкости;
	\item Фаза оценки (Evaluation Phase): оценивается полезность и стоимость выполнения задач;
	\item Фаза определения платежей (Payment Phase): аукционер (центральный контроллер) решает оптимальную задачу распределения, на основе этого решения рассчитываются платежи по механизму VCG, задачи назначаются узлам, выполняются платежи.
\end{enumerate}

\subsection{Фаза 1 -- Сбор информации (Submission Phase)}\label{sec:ch2/sec2/subsec1}

На первом фазе агенты устройств $d_{i}$ в момент времени $t$ отправляют заявку на выполнение задач:
\begin{equation}
	\text{Bid}_i(t) = \{\tau_1, \tau_2, \ldots, \tau_{l_i}\}, \quad \text{где } \tau_j = (\text{CPU}, \text{MEM}, \text{Priority}, \ldots)
\end{equation}

С другой стороны каждый узел $n_j$ объявляет доступные ресурсы:
\begin{equation}
	\text{Capacity}_j(t) = (\text{CPU}_{\text{avail}}, \text{MEM}_{\text{avail}}, \text{Bandwidth}_{\text{avail}})
\end{equation}

\subsection{Фаза 2 -- Оценка (Evaluation Phase)}\label{sec:ch2/sec2/subsec2}

На второй фазе сначала оценивается полезность и стоимость выполнения задач. 

\textbf{Функция полезности} является количественной оценкой <<выгоды>> или <<удовлетворенности>> устройства $d_i$ от выполнения его задачи на узле $n_j$, учитывающая базовую ценность задачи, штраф за задержку выполнения и энергетические затраты~\cite{li}:
\begin{equation}
	U_i\left( \tau, n_j, t \right) = V_i(\tau) \cdot \phi\left( \tau, n_j, t \right) - E_{i}(\tau,n_j).
\end{equation}

\textit{Базовая ценность} задачи определяет, сколько <<пользы>> принесет устройству успешное выполнение задачи:
\begin{equation}
	V_j(\tau) = \text{Priority}(\tau) \cdot (\text{CPU}(\tau) + \text{MEM}(\tau)) \cdot \beta_i,
\end{equation}
где $\beta_i$ -- коэффициент значимости для устройства $d_i$.

\textit{Функция штрафа за задержку} определяет, насколько эта польза уменьшается из-за задержки и растет экспоненциально -- это отражает важность соблюдения временных ограничений в IoT-системах:
\begin{equation}
	\phi\left( \tau, n_j, t \right) =  e^{-\lambda \cdot\frac{\text{EstimatedTime}(\tau, n_j, t)}{\text{Deadline}(\tau)}},
\end{equation}
где $\lambda$ -- коэффициент чувствительности к задержке, $\text{EstimatedTime}(\tau, n_j, t)$ -- предполагаемое время выполнения задачи на узле $n_j$.

\textit{Энергозатраты} на выполнение задачи могут быть определены, например, через затраты на передачу данных:
\begin{equation}
	E_i(\tau, n_j) = \text{DataSize}(\tau) \cdot w(d_i, n_j) \cdot e_{\text{trans}}.
\end{equation}

\textbf{Функция стоимости} в свою очередь оценивает затраты, которые несет узел $n_{j}$ при выполнении задачи от устройства $d_{i}$ с учётом вычислительных затрат, коммуникационных расходов и стоимости перегрузки~\cite{qiu}:
\begin{equation}
	C_j\left( \tau, d_i, t \right) = C_{comp}(\tau) + C_{comm}\left( \tau,d_i \right) + C_{overload}(\tau, t).
\end{equation}

\textit{Вычислительная стоимость} отражает реальные издержки на вычисления:
\begin{equation}
	C_{comp}(\tau) = \rho_{cpu} \cdot CPU(\tau) + \rho_{mem} \cdot MEM(\tau),
\end{equation}
где $\rho_{cpu}$ и $\rho_{mem}$ -- удельные стоимости CPU и памяти.

\textit{Коммуникационная стоимость} моделирует <<цену>> передачи данных:
\begin{equation}
	C_{comm}\left( \tau,d_i \right) = 
	\begin{cases}
		w\left( d_i,n_j \right) \cdot DataSize(\tau) \cdot \rho_{net} & \text{если } (d_i,n_j) \in E \\
		dist\left( d_i,n_j \right) \cdot DataSize(t) \cdot \rho_{net} \cdot \gamma & \text{если } (d_i,n_j) \notin E
	\end{cases},
\end{equation}
где $w\left( d_i,n_j \right)$ -- прямой вес ребра между устройством и узлом, $dist\left( d_i,n_j \right)$ -- кратчайшее расстояние в графе, $\rho_{net}$ -- стоимость единицы сетевого трафика, $\gamma > 1$ -- штраф за непрямое соединение.

\textit{Стоимость перегрузки} позволяет учесть не только прямые затраты, но и косвенные эффекты, такие как снижение производительности при высокой загрузке.
\begin{equation}
	C_{overload}(\tau, t) = \rho_{overload} \cdot \max(0, \sum_{\tau} \text{Requirement}(\tau) - \text{Capacity}_j(t))^2.
\end{equation}

\subsection{Фаза 3 -- Определение  платежей (Payment Phase)}\label{sec:ch2/sec2/subsec3}

На третьей фазе агент-аукционера решает оптимальную задачу распределения. Глобальная целевая функция -- \textbf{социальное благополучие (Social Welfare)} -- определяется как сумма всех выигрышей за вычетом затрат:
\begin{equation}
	SW(t) = \sum_{i=1}^{m} \sum_{\tau \in T_i(t)} \sum_{j=1}^{k} x_{i,j}^{\tau}(t) \cdot [U_i(\tau, n_j) - C_j(\tau, d_i)]
\end{equation}
где $x_{i,j}^{\tau}(t) \in \{0, 1\}$ -- индикаторная переменная, указывающая, выполняется ли задача $\tau$ на узле $n_j$ в момент времени $t$.

Максимизация социального благополучия обеспечивает глобальную оптимальность распределения при учёте интересов всех участников~\cite{arrow}.
\begin{equation}
	x^*(t) = \arg\max_{x} SW(t)
\end{equation}

Эта задача может быть решена различными методами:
\begin{itemize}
	\item для малых систем: методы целочисленного программирования;
	\item для больших систем: приближённые алгоритмы (жадные методы, метаэвристики);
	\item с обучением: MARL методы.
\end{itemize}

Центральным элементом решения является \textbf{механизм VCG (Vickrey-Clarke-Groves) платежей}, определяющий сколько должно заплатить устройство, чтобы у агентов не было стимула лгать о своей полезности / стоимости.
\begin{equation}
	p_i(\tau, t) = H_i(\tau) - [{SW}_{- i}(t) - (SW(t) - v_{i}(x_i^{*}))],
\end{equation}
где ${SW}_{- i}$ -- оптимальное социальное благополучие без участия устройства $d_i$, $v_i(x_i^{*})$ -- полученная ценность агентом $d_i$ при оптимальном распределении, $H_i(\tau)$ -- поправка (обычно 0 для простого VCG).

\subsection{Анализ свойств}\label{sec:ch2/sec2/subsec4}

\textbf{Теорема 2.4.1 (Доминантно-стратегическая совместимость -- DSIC):}

Если функции полезности и стоимости истинны, то для каждого устройства $d_i$ при платежах по VCG выполняется:

\begin{equation}
	U_i(\text{истинная заявка}) \geq U_i(\text{любая другая заявка})
\end{equation}

\textit{Доказательство:} Вытекает из свойств VCG механизма.

\textbf{Теорема 2.4.2 (Максимизация социального благосустояния):}

Распределение $x^*$, полученное путём решения задачи оптимизации, максимизирует сумму полезностей всех участников минус сумму затрат.

\textbf{Следствие (Индивидуальная рациональность):}

При правильном выборе $H_i(\tau)$, каждое устройство получает неотрицательную чистую полезность:

\begin{equation}
	U_i(\tau, n_j, t) - p_i(\tau, t) \geq 0
\end{equation}

\section{Алгоритм Dec-POMDP-MARL (QMIX)}\label{sec:ch2/sec3}




